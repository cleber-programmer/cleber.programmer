{"version":3,"sources":["rex.js","helpers/contains/contains.js","helpers/guid/guid.js","services/radio/emit.js","services/radio/handlers.js","services/radio/proxy.js","services/radio/radio.js","services/storage/drop.js","services/storage/get.js","services/storage/remove.js","services/storage/set.js","services/storage/storage.js","wrappers/flip/flip.js","wrappers/atom/atom.js","wrappers/atom/attached.js","wrappers/atom/change.js","wrappers/atom/component.js","wrappers/atom/created.js","wrappers/atom/detached.js","wrappers/atom/event.js","wrappers/hook/after.js","wrappers/hook/before.js","wrappers/hook/hook.js","wrappers/memoize/decorate.js","wrappers/memoize/memoize.js","wrappers/memoize/wrapper.js","wrappers/overload/overload.js"],"names":["modules","proxy","_extends","window","Rex","nameOrModule","module","push","onload","forEach","Proxy","@","get","target","name","receiver","value","test","indexOf","Date","now","Math","random","toString","_ref","radio","handlers","emit","channel","_len","arguments","length","args","Array","_key","_iterator","entries","_isArray","isArray","_i","Symbol","iterator","_ref4","next","done","_ref2","_ref3","_slicedToArray","context","_iterator2","_isArray2","_i2","_ref5","apply","JSON","parse","stringify","this","Map","set","Set","drop","clear","off","delete","on","add","storage","localStorage","key","defaultValue","undefined","getItem","remove","removeItem","setItem","Object","prototype","call","predicate","reverse","atom","hook","attached","prop","descriptor","hookCallback","setImmediate","bind","after","contains","change","properties","oldValue","newValue","before","component","tagName","extending","document","registerElement","_defineProperty","create","HTMLElement","created","detached","event","query","bubbling","action","e","matches","hookCreatedCallback","addEventListener","hookDetachedCallback","removeEventListener","memoize","method","flip","decorate","wrapper","1","3","taraget","overrid"],"mappings":"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","file":"rex.min.js","sourcesContent":["(function (modules, proxy) {\r\n\r\n  /**\r\n   * Extendo o objeto window, com o modulo 'Rex' e subscrevo\r\n   * o evento onload\r\n   */\r\n  Object.assign(window, {\r\n\r\n    /**\r\n     * Principal Funcao responsavel por registrar e consumir\r\n     * Modulos, utilizando-se da sobrecarga\r\n     */\r\n    Rex(nameOrModule, module) {\r\n      module ? (proxy[nameOrModule] = module) : modules.push(nameOrModule);\r\n    },\r\n\r\n    /**\r\n     * Inicializacao dos Modulos aguarda o evento onload, permitindo\r\n     * hoisting dos Modulos registrado\r\n     */\r\n    onload() {\r\n      modules.forEach(module => module(proxy));\r\n    }\r\n\r\n  });\r\n\r\n/**\r\n * Inicializa o Modulo passando como parametro, um Array Literal e\r\n * um Proxy que faz todo o trabalho de Injecao de Dependencia\r\n */\r\n})([], new Proxy({ '@': {} }, {\r\n  \r\n  /**\r\n   * Intermedeia as chamadas dos Modulos, memoizando o retorno da Funcao\r\n   * construtora\r\n   */\r\n  get(target, name, receiver) {\r\n    return target['@'][name] || (target['@'][name] = target[name](receiver));\r\n  }\r\n  \r\n}));","Rex('contains', function () {\r\n\r\n  /**\r\n   * Este modulo rerifica a existencia de um valor\r\n   * dentro de uma colecao\r\n   */\r\n  return function (value, target) {\r\n    return !/\\-1/.test(target.indexOf(value));\r\n  };\r\n\r\n});","Rex('guid', function () {\r\n\r\n  /**\r\n   * Este module cria um valor unico a todo momento que4\r\n   * for chamado\r\n   */\r\n  return function () {\r\n    return (Date.now() * Math.random()).toString(36);\r\n  };\r\n\r\n});","Rex(function ({ radio, ['radio.handlers']: handlers }) {\r\n\r\n  /**\r\n   * Estende a class radio com o metodo statico emit\r\n   */\r\n  Object.assign(radio, {\r\n\r\n    /**\r\n     * Emite uma transmissao em um canal especifico, para todos os contextos, repassando\r\n     * uma copia do que foi passado na transmissao\r\n     */\r\n    emit(channel, ...args) {\r\n      for (let [context, proxy] of handlers.entries())\r\n        for (let target of proxy[channel]) target.apply(context, JSON.parse(JSON.stringify(args)));\r\n      return this;\r\n    }\r\n\r\n  });\r\n\r\n});","/**\r\n * Mapa para guardar todos os contexto, que deposi sera muito\r\n * facil para realizar o metodo drop\r\n */\r\nRex('radio.handlers', () => new Map);","Rex('radio.proxy', function ({ ['radio.handlers']: handlers }) {\r\n\r\n  /**\r\n   * Conjultando o contexto com um Proxy, quey ira armazenar os\r\n   * canais\r\n   */\r\n  return function (context) {\r\n    handlers.set(context, new Proxy({}, {\r\n\r\n      /**\r\n       * Se um canal ainda nao existir, sera criado o canal e atribuido\r\n       * um novo Set\r\n       */\r\n      get(target, name) {\r\n        return target[name] || (target[name] = new Set);\r\n      }\r\n\r\n    }));\r\n  };\r\n\r\n});","Rex('radio', function ({ ['radio.handlers']: handlers, ['radio.proxy']: proxy }) {\r\n\r\n  /**\r\n   * Uma classe da forma tradicionar, desta forna nao sera\r\n   * preciso do operado new para instanciar\r\n   */\r\n  return function radio(context) {\r\n\r\n    /**\r\n     * Para utilizarmos o new em todas as refencias, forço de\r\n     * forma transparente a criacao de uma nova instancia\r\n     */\r\n    if (!(this instanceof radio)) {\r\n      return new radio(context);\r\n    }\r\n\r\n    /**\r\n     * Conjultando o contexto com um Proxy, quey ira armazenar os\r\n     * canais\r\n     */\r\n    proxy(context);\r\n\r\n    /**\r\n     * Desliga todas as escultas\r\n     */\r\n    function drop() {\r\n      return handlers.get(context).clear(), this;\r\n    }\r\n\r\n    /**\r\n     * Localiza dentro do Map o canal pelo contexto conjulgado\r\n     */\r\n    function get(channel) {\r\n      return handlers.get(context)[channel];\r\n    }\r\n\r\n    /**\r\n     * Desliga a esculta de uma transmissao especifica\r\n     */\r\n    function off(channel, target) {\r\n      return get(channel).delete(target), this;\r\n    }\r\n\r\n    /**\r\n     * Liga a esculta para uma transmissao especifica\r\n     */\r\n    function on(channel, target) {\r\n      return get(channel).add(target), this;\r\n    }\r\n\r\n    /**\r\n     * Pattern revelation\r\n     */\r\n    return { drop, off, on };\r\n\r\n  };\r\n\r\n});","Rex(function ({ storage }) {\r\n\r\n  /**\r\n   * Extensao do modulo Storage, incluindo o metodo drop que limpa\r\n   * todas as chaves com seu valores\r\n   */\r\n  Object.assign(storage, {\r\n    drop: function () {\r\n\r\n      /**\r\n       * Limpa as chaves -> valores, posteriormente retornando o\r\n       * proprio objeto Storage\r\n       */\r\n      return localStorage.clear(), storage;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ storage }) {\r\n\r\n  /**\r\n   * Extensao do modulo Storage, incluindo o metodo get devolve o valor\r\n   * pela chave fornecido\r\n   */\r\n  Object.assign(storage, {\r\n    get: function (key, defaultValue = null) {\r\n\r\n      /**\r\n       * Parseia o valor caso ele seja um Objeto ou uma Colecao, caso contrario\r\n       * devolve o proprio valor, por padrao o valor sera uma Literal\r\n       */\r\n      function parse(value) {\r\n        return /^(\\{|\\[).+(\\]|\\})$/.test(value) ? JSON.parse(value) : value;\r\n      }\r\n\r\n      /**\r\n       * Devolve o valor referente a chave que fora passado, caso nao\r\n       * encontrado o valor devolve o valor padrao\r\n       */\r\n      return parse(localStorage.getItem(key)) || defaultValue;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ storage }) {\r\n\r\n  /**\r\n   * Extensao do modulo Storage, incluindo o metodo remove a chave\r\n   */\r\n  Object.assign(storage, {\r\n    remove: function (key) {\r\n\r\n      /**\r\n       * Exlusao da chave e devolve a referencia do Storage\r\n       */\r\n      return localStorage.removeItem(key), storage;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ storage }) {\r\n\r\n  /**\r\n   * Extensao do modulo Storage, incluindo o metodo set cria e/ou altera o valor\r\n   * pela chave forcecia\r\n   */\r\n  Object.assign(storage, {\r\n    set: function (key, value = null) {\r\n\r\n      /**\r\n       * Verifica se o valor fornecido é um Objeto ou Array, para executar\r\n       * o parse para Literal antes de ser armazenado evitando erros ou referencia\r\n       */\r\n      function is(value) {\r\n        return /(object|array)\\]$/i.test(Object.prototype.toString.call(value));\r\n      }\r\n\r\n      /**\r\n       * Cria e/ou altera o valor da chave e devolve a referencia do Storage\r\n       */\r\n      return localStorage.setItem(key, is(value) ? JSON.stringify(value) : value), storage;\r\n\r\n    }\r\n  });\r\n\r\n});","/**\r\n * Um micro Base de Dados com persistencia de sessao, que trabalha\r\n * com chave -> valor\r\n */\r\nRex('storage', () => ({}));","Rex('flip', function () {\r\n\r\n  /**\r\n   * Este modulo inverte a ordem dos pararametro e repassando para o\r\n   * predicate encapsulado\r\n   */\r\n  return function (predicate) {\r\n\r\n    /**\r\n     * Rece os argumentos atraves do parametro ...args onde sera\r\n     * frito a inversao desses valores sendo aplicado no predicado\r\n     */\r\n    return function (...args) {\r\n      return predicate.apply(this, args.reverse());\r\n    };\r\n\r\n  };\r\n\r\n});","/**\r\n * Modulo com decoradores de classes que auxiliam na criacao do\r\n * component customizado\r\n */\r\nRex('atom', () => ({}));","Rex(function ({ atom, hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, decorador attached executa um metodo\r\n   * quando o Web Component for apendado no DOM\r\n   */\r\n  Object.assign(atom, {\r\n    attached(target, prop, descriptor) {\r\n\r\n      /**\r\n       * Hook que executara o metodo apontado no decorador no evento\r\n       * de attachedCallback\r\n       */\r\n      function hookCallback() {\r\n        setImmediate(this[prop].bind(this));\r\n      }\r\n\r\n      /**\r\n       * Troca o metodo attachedCallbac pelo hookCallback que fara o \r\n       * disparo para o metodo apontotado no decorador no momento em que\r\n       * o Web Component for atachado no DOM\r\n       */\r\n      hook.after(target, 'attachedCallback', hookCallback);\r\n\r\n      /**\r\n       * Retorna o descriptor sem nenhuma modificacao\r\n       */\r\n      return descriptor;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ atom, contains, hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, o decorador change notifica o metodo\r\n   * decorado quando o atributo identificado for alterado\r\n   */\r\n  Object.assign(atom, {\r\n    change(...properties) {\r\n      return function (target, prop, descriptor) {\r\n\r\n        /**\r\n         * Notifica o metodo que fora decorado, para receber o novo valor da\r\n         * propriedade alterado\r\n         */\r\n        function hookCallback(name, oldValue, newValue) {\r\n          contains(name, properties) && (this[prop](newValue, oldValue, name));\r\n        }\r\n\r\n        /**\r\n         * Altera o metodo attributeChangedCallback para incluir o hook, no momento\r\n         * que este metodo for chamado, sera repassado para o metodo que fora decorado\r\n         */\r\n        hook.before(target, 'attributeChangedCallback', hookCallback);\r\n\r\n        return descriptor;\r\n\r\n      };\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ atom }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, o decorador componente cria um componente\r\n   * como o nome da tag quer fora passado\r\n   */\r\n\tObject.assign(atom, {\r\n    component(tagName, extending) {\r\n      return function (target) {\r\n\r\n        /**\r\n         * Cria um novo Web Components customizado, desde que o nome da tag tenha\r\n         * um hifen e que este nome ja nao foi registrado\r\n         */\r\n      \tdocument.registerElement(tagName, {\r\n          prototype: Object.assign(Object.create(HTMLElement.prototype), target.prototype),\r\n          [extending ? 'extends' : '']: extending\r\n        });\r\n\r\n      };\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ atom, hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, funciona com um constructor;\r\n   * Decorador created executa um metodo quando o Web Component for\r\n   * criado, antes de ser apendado no DOM\r\n   */\r\n  Object.assign(atom, {\r\n    created(target, prop, descriptor) {\r\n\r\n      /**\r\n       * Hook que executara o metodo apontado no decorador no evento\r\n       * de createdCallback\r\n       */\r\n      function hookCallback() {\r\n        setImmediate(this[prop].bind(this));\r\n      }\r\n\r\n      /**\r\n       * Troca o metodo createdCallbac pelo hookCallback que fara o \r\n       * disparo para o metodo apontotado no decorador no momento em que\r\n       * o Web Component for criado\r\n       */\r\n      hook.after(target, 'createdCallback', hookCallback);\r\n\r\n      /**\r\n       * Retorna o descriptor sem nenhuma modificacao\r\n       */\r\n      return descriptor;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ atom, hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, funciona como um deconstructor;\r\n   * Decorador detached executa um metodo quando o Web Component\r\n   * for retirado do DOM\r\n   */\r\n  Object.assign(atom, {\r\n    detached(target, prop, descriptor) {\r\n\r\n      /**\r\n       * Hook que executara o metodo apontado no decorador no evento\r\n       * de detachedCallback\r\n       */\r\n      function hookCallback() {\r\n        this[prop]();\r\n      }\r\n\r\n      /**\r\n       * Troca o metodo detachedCallbac pelo hookCallback que fara o \r\n       * disparo para o metodo apontotado no decorador no momento em que\r\n       * o Web Component for retirado do DOM\r\n       */\r\n      hook.after(target, 'detachedCallback', hookCallback);\r\n\r\n      /**\r\n       * Retorna o descriptor sem nenhuma modificacao\r\n       */\r\n      return descriptor;\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ atom, hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo atom, executa os metodo apontoado no decorado que\r\n   * indica o evento de interesse que atenda a query de selecao\r\n   */\r\n  Object.assign(atom, {\r\n    event(event, query = '*', bubbling) {\r\n      return function (target, prop, descriptor) {\r\n\r\n        /**\r\n         * Executa o metodo hook quey foi decorado pelo decorador\r\n         * event\r\n         */\r\n        function action(e) {\r\n          e.target.matches(query) && this[prop](e);\r\n        }\r\n\r\n        /** \r\n         * Quando o evento createdCallback for disparado, sera adicionado\r\n         * o evento que fora informado no decorator\r\n         */\r\n        function hookCreatedCallback() {\r\n          this.addEventListener(event, action.bind(this), bubbling);\r\n        }\r\n\r\n        /** \r\n         * Quando o evento detachedCallback for disparado, sera removido\r\n         * o evento que fora informado no decorator\r\n         */\r\n        function hookDetachedCallback() {\r\n          this.removeEventListener(event, action.bind(this), bubbling);\r\n        }\r\n\r\n        /**\r\n         * Adiciona um hook no metodo createdCallbac pelo hookCreatedCallback \r\n         */\r\n        hook.after(target, 'createdCallback', hookCreatedCallback);\r\n\r\n        /**\r\n         * Adiciona um hook no metodo detachedCallbac pelo hookDetachedCallback \r\n         */\r\n        hook.after(target, 'detachedCallback', hookDetachedCallback);\r\n\r\n        /**\r\n         * Retorna o descriptor sem nenhuma modificacao\r\n         */\r\n        return descriptor;\r\n\r\n      };\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ hook, memoize }) {\r\n\r\n  /**\r\n   * Extensao do modulo Hook, inclusao da funcao after, que\r\n   * executara apos a execao da funcao indicada\r\n   */\r\n  Object.assign(hook, {\r\n    after: function (target, prop, predicate) {\r\n\r\n      (function (method) {\r\n\r\n        /**\r\n         * Sobrescreve o predicator horiginal trocando pelo hook, apos a execucao\r\n         * do predicate horiginal sera passa o retorno para o hook que tambem\r\n         * devera retornar o valo\r\n         */\r\n        Object.assign(target, {\r\n        \t[prop]() {\r\n        \t\treturn predicate.call(this, method.apply(this, arguments)), method.apply(this, arguments);\r\n        \t}\r\n        });\r\n      \r\n      /**\r\n       * Passando como parametro a funcao/metodo que tera o hook, caso\r\n       * a funcao nao exista sera passado um stub\r\n       */\r\n      })(memoize(target[prop] || function () {}));\r\n\r\n    }\r\n  });\r\n\r\n});","Rex(function ({ hook }) {\r\n\r\n  /**\r\n   * Extensao do modulo Hook, inclusao da funcao before, que\r\n   * executara apos a execao da funcao indicada\r\n   */\r\n  Object.assign(hook, {\r\n    before: function (target, prop, predicate) {\r\n\r\n      (function (method) {\r\n\r\n        /**\r\n         * Sobrescreve o predicator horiginal trocando pelo hook, sera executado\r\n         * antes que recebera todos os parametros adicionado o predicate horiginal no\r\n         * final dos argumentos\r\n         */\r\n        Object.assign(target, {\r\n        \t[prop]() {\r\n        \t\treturn predicate.apply(this, arguments), method.apply(this, arguments);\r\n        \t}\r\n        });\r\n      \r\n      /**\r\n       * Passando como parametro a funcao/metodo que tera o hook, caso\r\n       * a funcao nao exista sera passado um stub\r\n       */\r\n      })(target[prop]);\r\n\r\n    }\r\n  });\r\n\r\n});","/**\r\n * Hooks que seram executados antes e/ou depois da execucao\r\n * da funcao indicada\r\n */\r\nRex('hook', () => ({}));","Rex('memoize.decorate', function ({ flip, hook }) {\r\n\r\n  /**\r\n   * Este docorador tem a responsabilidade de cachear o retorno do\r\n   * metodo, evitando que o metodo horiginal seja executado em chamadas\r\n   * sequentes\r\n   */\r\n  return function (target, key, descriptor) {\r\n\r\n    /**\r\n     * Hook que verifica se o metodo alvo ja fora chamado, retornando\r\n     * o valor cacheado\r\n     */\r\n    function hookCallback(method, ...args) {\r\n      return this[`@${args}`] || (this[`@${args}`] = method.apply(this, args));\r\n    }\r\n\r\n    /**\r\n     * Encapsula o metodo horiginal pelo hookCallback\r\n     */\r\n    hook.before(descriptor, 'value', flip(hookCallback));\r\n\r\n    /**\r\n     * Retorna o descriptor com o metodo alvo alterado\r\n     * pela funcao hookCallback\r\n     */\r\n    return descriptor;\r\n    \r\n  }\r\n\r\n});","Rex('memoize', function ({ ['memoize.decorate']: decorate, ['memoize.wrapper']: wrapper }) {\r\n\r\n  /**\r\n   * Cacheia o retorno da funcao/metodo, evitando que a execucao do predicado\r\n   * seja executado em chamadas futuras\r\n   */\r\n  return function () {\r\n\r\n    /**\r\n     * Encontra o modulo correspondente pela o numero\r\n     * de parametros correspondente ao numero de argumentos\r\n     */\r\n    return {\r\n        '1': wrapper\r\n      , '3': decorate\r\n    }[arguments.length].apply(this, arguments);\r\n\r\n  };\r\n\r\n});","Rex('memoize.wrapper', function ({ flip, hook }) {\r\n\r\n  /**\r\n   * Este wrapper tem a responsabilidade de cachear o retorno do\r\n   * metodo, evitando que o metodo horiginal seja executado em chamadas\r\n   * sequentes\r\n   */\r\n  return function (target) {\r\n    return function () {\r\n\r\n      /**\r\n       * Verifica se o metodo alvo ja fora chamado, retornando\r\n       * o valor cacheado\r\n       */\r\n      return target[`@${arguments}`] || (target[`@${arguments}`] = target.apply(this, arguments));\r\n\r\n    }\r\n    \r\n  }\r\n\r\n});","Rex('overload', function () {\r\n\r\n  /**\r\n   * Modulo olverload é uma sobre carga de metodos, pela\r\n   * quantidades de paremetros e nao pelo tipo de dados como em\r\n   * linguagens que com tipagem de dados\r\n   */\r\n  return function (taraget, key, overrid) {\r\n    (function (method) {\r\n\r\n      /**\r\n       * Se a quantidade de items passados em arguments for correspondente\r\n       * com o tamanho do overrid entao sera executado, caso contrario sera executado\r\n       * o metodo que fora sobre carregado\r\n       */\r\n      Object.assign(taraget, {\r\n        [key]() {\r\n          return (overrid.length == arguments.length ? overrid : method).apply(this, arguments);\r\n        }\r\n      });\r\n\r\n    })(taraget[key]);\r\n  };\r\n\r\n});"]}