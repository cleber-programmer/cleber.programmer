{"version":3,"sources":["emit.js","handlers.js","radio.js"],"names":["Rex","radio","handlers","emit","channel","args","entries","context","proxy","target","apply","JSON","parse","stringify","Map","set","Proxy","get","name","Set","drop","clear","off","delete","on","add"],"mappings":"02BAAAA,IAAI,cAAmD,IAAvCC,MAAuC,MAAvCA,KAAuC,CAAZC,QAAY,MAA/B,gBAA+B;;;;;AAKrD,SAAcD,KAAd,CAAqB;;;;;;AAMnBE,IANmB,eAMdC,OANc,CAMI,+BAANC,IAAM,iDAANA,IAAM;AACrB,kBAA6BH,SAASI,OAAT,EAA7B,wUAAUC,QAAV,aAAmBC,MAAnB;AACE,mBAAmBA,MAAMJ,OAAN,CAAnB,sSAASK,OAAT,OAAmCA,OAAOC,KAAP,CAAaH,OAAb,CAAsBI,KAAKC,KAAL,CAAWD,KAAKE,SAAL,CAAeR,IAAf,CAAX,CAAtB,EAAnC,CADF;AAEA,MAAO,KAAP;AACD,CAVkB,CAArB;;;;AAcD,CAnBD;ACAAL,IAAI,gBAAJ,CAAsB,iBAAM,IAAIc,IAAJ,EAAN,EAAtB;ACAAd,IAAI,OAAJ,CAAa,cAA4C,IAAZE,SAAY,MAA/B,gBAA+B;;AAEvD,MAAO,SAASD,MAAT,CAAeM,OAAf,CAAwB;;;;;;AAM7B,GAAI,EAAE,eAAgBN,MAAlB,CAAJ,CAA8B;AAC5B,MAAO,IAAIA,MAAJ,CAAUM,OAAV,CAAP;AACD;;;;;;AAMDL,SAASa,GAAT,CAAaR,OAAb,CAAsB,GAAIS,MAAJ,CAAU,EAAV,CAAc;;;;;;AAMlCC,GANkC,cAM9BR,MAN8B,CAMtBS,IANsB,CAMhB;AAChB,MAAOT,QAAOS,IAAP,IAAiBT,OAAOS,IAAP,EAAe,GAAIC,IAAJ,EAAhC,CAAP;AACD,CARiC,CAAd,CAAtB;;;;;;;AAeA,QAASC,KAAT,EAAgB;AACd,MAAOlB,UAASe,GAAT,CAAaV,OAAb,EAAsBc,KAAtB,GAA+B,IAAtC;AACD;;;;;AAKD,QAASJ,IAAT,CAAab,OAAb,CAAsB;AACpB,MAAOF,UAASe,GAAT,CAAaV,OAAb,EAAsBH,OAAtB,CAAP;AACD;;;;;AAKD,QAASkB,IAAT,CAAalB,OAAb,CAAsBK,MAAtB,CAA8B;AAC5B,MAAOQ,KAAIb,OAAJ,EAAamB,MAAb,CAAoBd,MAApB,EAA6B,IAApC;AACD;;;;;AAKD,QAASe,GAAT,CAAYpB,OAAZ,CAAqBK,MAArB,CAA6B;AAC3B,MAAOQ,KAAIb,OAAJ,EAAaqB,GAAb,CAAiBhB,MAAjB,EAA0B,IAAjC;AACD;;;;;AAKD,MAAO,CAAEW,SAAF,CAAQE,OAAR,CAAaE,KAAb,CAAP;;AAED,CA3DD;;AA6DD,CA/DD","file":"rex.radio.min.js","sourcesContent":["Rex(function ({ radio, ['radio.handlers']: handlers }) {\r\n\r\n  /**\r\n   * Estende a class radio com o metodo statico emit\r\n   */\r\n  Object.assign(radio, {\r\n\r\n    /**\r\n     * Emite uma transmissao em um canal especifico, para todos os contextos, repassando\r\n     * uma copia do que foi passado na transmissao\r\n     */\r\n    emit(channel, ...args) {\r\n      for (let [context, proxy] of handlers.entries())\r\n        for (let target of proxy[channel]) target.apply(context, JSON.parse(JSON.stringify(args)));\r\n      return this;\r\n    }\r\n\r\n  });\r\n\r\n});","Rex('radio.handlers', () => new Map);","Rex('radio', function ({ ['radio.handlers']: handlers }) {\r\n\r\n  return function radio(context) {\r\n\r\n    /**\r\n     * Para utilizarmos o new em todas as refencias, for√ßo de\r\n     * forma transparente a criacao de uma nova instancia\r\n     */\r\n    if (!(this instanceof radio)) {\r\n      return new radio(context);\r\n    }\r\n\r\n    /**\r\n     * Conjultando o contexto com um Proxy, quey ira armazenar os\r\n     * canais\r\n     */\r\n    handlers.set(context, new Proxy({}, {\r\n\r\n      /**\r\n       * Se um canal ainda nao existir, sera criado o canal e atribuido\r\n       * um novo Set\r\n       */\r\n      get(target, name) {\r\n        return target[name] || (target[name] = new Set);\r\n      }\r\n\r\n    }));\r\n\r\n    /**\r\n     * Desliga todas as escultas\r\n     */\r\n    function drop() {\r\n      return handlers.get(context).clear(), this;\r\n    }\r\n\r\n    /**\r\n     * Localiza dentro do Map o canal pelo contexto conjulgado\r\n     */\r\n    function get(channel) {\r\n      return handlers.get(context)[channel];\r\n    }\r\n\r\n    /**\r\n     * Desliga a esculta de uma transmissao especifica\r\n     */\r\n    function off(channel, target) {\r\n      return get(channel).delete(target), this;\r\n    }\r\n\r\n    /**\r\n     * Liga a esculta para uma transmissao especifica\r\n     */\r\n    function on(channel, target) {\r\n      return get(channel).add(target), this;\r\n    }\r\n\r\n    /**\r\n     * Pattern revelation\r\n     */\r\n    return { drop, off, on };\r\n\r\n  };\r\n\r\n});"]}