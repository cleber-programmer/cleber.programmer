{"version":3,"sources":["radio.js"],"names":["Rex","_","_ref","radio","context","drop","handlers","get","clear","this","channel","off","target","delete","on","add","set","Proxy","name","Set","_ref$handlers","undefined","Map","_extends","emit","_len","arguments","length","args","Array","_key","_iterator","entries","_isArray","isArray","_i","Symbol","iterator","_ref4","next","done","value","_ref2","_ref3","_slicedToArray","proxy","_iterator2","_isArray2","_i2","_ref5","apply","JSON","parse","stringify"],"mappings":"grBAAAA,KAAI,QAAS,SAAUC,EAAVC,GAEX,QAASC,GAAMC,GA6Bb,QAASC,KACP,MAAOC,GAASC,IAAIH,GAASI,QAASC,KAMxC,QAASF,GAAIG,GACX,MAAOJ,GAASC,IAAIH,GAASM,GAM/B,QAASC,GAAID,EAASE,GACpB,MAAOL,GAAIG,GAASG,OAAOD,GAASH,KAMtC,QAASK,GAAGJ,EAASE,GACnB,MAAOL,GAAIG,GAASK,IAAIH,GAASH,KA7CnC,MAAMA,gBAAgBN,IAQtBG,EAASU,IAAIZ,EAAS,GAAIa,WAMxBV,IANkC,SAM9BK,EAAQM,GACV,MAAON,GAAOM,KAAUN,EAAOM,GAAQ,GAAIC,WAoCtCd,KAAAA,EAAMM,IAAAA,EAAKG,GAAAA,IAlDX,GAAIX,GAAMC,GAT6B,GAAAgB,GAAAlB,EAAxBI,SAAAA,EAAwBe,SAAAD,EAAb,GAAIE,KAASF,CAkElD,OAAOG,UAAcpB,GAMnBqB,KAN0B,SAMrBd,GAAkB,IAAA,GAAAe,GAAAC,UAAAC,OAANC,EAAMC,MAAAJ,EAAA,EAAAA,EAAA,EAAA,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAANF,EAAME,EAAA,GAAAJ,UAAAI,EACrB,KAAA,GAAAC,GAA6BzB,EAAS0B,UAAtCC,EAAAJ,MAAAK,QAAAH,GAAAI,EAAA,EAAAJ,EAAAE,EAAAF,EAAAA,EAAA,kBAAAK,QAAAA,OAAAC,SAAA,kBAAA,CAAA,GAAAC,EAAA,IAAAL,EAAA,CAAA,GAAAE,GAAAJ,EAAAJ,OAAA,KAAAW,GAAAP,EAAAI,SAAA,CAAA,GAAAA,EAAAJ,EAAAQ,OAAAJ,EAAAK,KAAA,KAAAF,GAAAH,EAAAM,MACE,IAAA,GADFC,GAAAJ,EAAAK,EAAAC,eAAAF,EAAA,GAAUtC,EAAVuC,EAAA,GAAmBE,EAAnBF,EAAA,GACEG,EAAmBD,EAAMnC,GAAzBqC,EAAAlB,MAAAK,QAAAY,GAAAE,EAAA,EAAAF,EAAAC,EAAAD,EAAAA,EAAA,kBAAAV,QAAAA,OAAAC,SAAA,kBAAA,CAAA,GAAAY,EAAA,IAAAF,EAAA,CAAA,GAAAC,GAAAF,EAAAnB,OAAA,KAAAsB,GAAAH,EAAAE,SAAA,CAAA,GAAAA,EAAAF,EAAAP,OAAAS,EAAAR,KAAA,KAAAS,GAAAD,EAAAP,MAAAQ,EAA0CC,MAAM9C,EAAS+C,KAAKC,MAAMD,KAAKE,UAAUzB,MACrF,MAAOnB","file":"rex.radio.min.js","sourcesContent":["Rex('radio', function (_, { handlers = new Map() }) {\r\n\r\n  function radio(context) {\r\n\r\n    /**\r\n     * Para utilizarmos o new em todas as refencias, for√ßo de\r\n     * forma transparente a criacao de uma nova instancia\r\n     */\r\n    if (!(this instanceof radio)) {\r\n      return new radio(context);\r\n    }\r\n\r\n    /**\r\n     * Conjultando o contexto com um Proxy, quey ira armazenar os\r\n     * canais\r\n     */\r\n    handlers.set(context, new Proxy({}, {\r\n\r\n      /**\r\n       * Se um canal ainda nao existir, sera criado o canal e atribuido\r\n       * um novo Set\r\n       */\r\n      get(target, name) {\r\n        return target[name] || (target[name] = new Set);\r\n      }\r\n\r\n    }));\r\n\r\n    /**\r\n     * Desliga todas as escultas\r\n     */\r\n    function drop() {\r\n      return handlers.get(context).clear(), this;\r\n    }\r\n\r\n    /**\r\n     * Localiza dentro do Map o canal pelo contexto conjulgado\r\n     */\r\n    function get(channel) {\r\n      return handlers.get(context)[channel];\r\n    }\r\n\r\n    /**\r\n     * Desliga a esculta de uma transmissao especifica\r\n     */\r\n    function off(channel, target) {\r\n      return get(channel).delete(target), this;\r\n    }\r\n\r\n    /**\r\n     * Liga a esculta para uma transmissao especifica\r\n     */\r\n    function on(channel, target) {\r\n      return get(channel).add(target), this;\r\n    }\r\n\r\n    /**\r\n     * Pattern revelation\r\n     */\r\n    return { drop, off, on };\r\n\r\n  }\r\n\r\n  /**\r\n   * Estende a class radio com o metodo statico emit\r\n   */\r\n  return Object.assign(radio, {\r\n\r\n    /**\r\n     * Emite uma transmissao em um canal especifico, para todos os contextos, repassando\r\n     * uma copia do que foi passado na transmissao\r\n     */\r\n    emit(channel, ...args) {\r\n      for (let [context, proxy] of handlers.entries())\r\n        for (let target of proxy[channel]) target.apply(context, JSON.parse(JSON.stringify(args)));\r\n      return this;\r\n    }\r\n\r\n  });\r\n\r\n});"]}